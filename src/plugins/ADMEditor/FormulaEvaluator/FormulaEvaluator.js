/**
 * Generated by PluginGenerator from webgme on Wed Aug 06 2014 14:03:02 GMT-0500 (Central Daylight Time).
 */

define(['plugin/PluginConfig', 'plugin/PluginBase', 'plugin/FormulaEvaluator/FormulaEvaluator/meta', 'plugin/FormulaEvaluator/FormulaEvaluator/dgraph', 'plugin/FormulaEvaluator/FormulaEvaluator/set', 'plugin/FormulaEvaluator/FormulaEvaluator/dataflow'], function(PluginConfig, PluginBase, MetaTypes, Dgraph, mySet, DF) {
    'use strict';

    /**
     * Initializes a new instance of FormulaEvaluator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin FormulaEvaluator.
     * @constructor
     */
    var FormulaEvaluator = function() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.idLUT = {};
    };

    // Prototypal inheritance from PluginBase.
    FormulaEvaluator.prototype = Object.create(PluginBase.prototype);
    FormulaEvaluator.prototype.constructor = FormulaEvaluator;

    /**
     * Gets the name of the FormulaEvaluator.
     * @returns {string} The name of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getName = function() {
        return "FormulaEvaluator";
    };

    /**
     * Gets the semantic version (semver.org) of the FormulaEvaluator.
     * @returns {string} The version of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getVersion = function() {
        return "0.1.0";
    };

    function _importJS(file) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file, false);
        xhr.send();
        var a = document.createElement("script");
        a.type = "text/javascript";
        a.text = xhr.responseText;
        document.getElementsByTagName("head")[0].appendChild(a);
    };

    function findServer(url) {
        var transport = new Thrift.Transport(url);
        var protocol = new Thrift.Protocol(transport);
        var client = new qudt4dt.thrift.Qudt4dt_baseClient(protocol);
        return client;
    };

    function convert(srcVal, srcUrl, dstUrl) {
        var client = findServer("http://localhost:8080/servlet/unit");
        var srcUnit = client.query(srcUrl);
        var srcQuantity = new qudt4dt.thrift.Quantity();
        srcQuantity.unit = srcUnit;
        srcQuantity.value = srcVal;
        var srcInfo = client.list_domain_unitset(srcQuantity);
        var dstQuantity = client.quantity_convert(srcQuantity, dstUrl);
        var dstInfo = client.list_domain_unitset(dstQuantity);
        return dstQuantity.value;
    };

    function size_dict(d) {
        var c = 0;
        for (var i in d)
        ++c;
        return c;
    };



    function assert(condition) {
        if (!condition) {
            throw "Assertion failed";
        }
    };
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */

    FormulaEvaluator.prototype.main = function(callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        self.updateMETA(self.metaTypes);

        var activeNode = self.activeNode;
        var start = (new Date()).getTime();

        //some utils
        _importJS("http://localhost:8080/servlet/thrift.js");
        _importJS("http://localhost:8080/servlet/gen-js/protocal_types.js");
        _importJS("http://localhost:8080/servlet/gen-js/Qudt4dt_base.js");


        // function traverse(doWith) {
        //     return function(err, children) {
        //         for (var i = 0; i < children.length; i += 1) {
        //             var node = children[i];
        //             var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
        //             if ('Container' == baseClass) {
        //                 self.core.loadChildren(node, traverse(doWith));
        //             } else {
        //                 doWith(node);
        //             }
        //         }
        //     };
        // };


        var test = function(err, children) {
            if (err) {
                return callback(err);
            }
            for (var i = 0; i < children.length; i += 1) {
                var node = children[i];
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ('Container' != baseClass) {
                    var gmePath = self.core.getPath(node);
                    console.log("Node name: " + gmePath);
                    self.idLUT[gmePath] = node;
                } else {
                    self.core.loadChildren(node, test);
                }

            }
        };

        var addComponentWithPath = function(node) {
            var gmePath = self.core.getPath(node);
            //var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
            console.log("Node name:" + gmePath);
            // if ('Container' == baseClass)
            //     self.core.loadChildren(node, traverse(addComponentWithPath));
            self.idLUT[gmePath] = node;
            //self.logger.info(gmePath+ ',' +self.idLUT[gmePath]);
        };

        var convertWithEdge = function(srcPathList, dstPath) {
            var start = (new Date()).getTime();
            assert(1 === srcPathList.length);
            var srcNode = self.idLUT[srcPathList[0]];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
            self.core.setAttribute(dstNode, 'Value', dstUnitVal);
            var end = (new Date()).getTime();
            console.log("Node Time:" + (end - start) + "ms");
            return true;
        };

        var max = function(srcPathList, dstFormulaPath) {
            var dstFormula = self.idLUT[dstFormulaPath];
            var dstUnitUrl = self.core.getAttribute(dstFormula, 'Unit');
            var ret = self.core.getAttribute(self.idLUT[srcPathList[0]], 'Value');
            for (var i = 1; i < srcPathList.length; ++i) {
                var srcNodePath = srcPathList[i];
                var srcNode = self.idLUT[srcNodePath];
                var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
                var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
                var val = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
                if (val > ret)
                    ret = val;
            };
            self.core.setAttribute(dstFormula, 'Value', ret);
            return true;
        };


        var min = function(srcPathList, dstFormulaPath) {
            var dstFormula = self.idLUT[dstFormulaPath];
            var dstUnitUrl = self.core.getAttribute(dstFormula, 'Unit');
            var ret = self.core.getAttribute(self.idLUT[srcPathList[0]], 'Value');
            for (var i = 1; i < srcPathList.length; ++i) {
                var srcNodePath = srcPathList[i];
                var srcNode = self.idLUT[srcNodePath];
                var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
                var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
                var val = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
                if (val < ret)
                    ret = val;
            };
            self.core.setAttribute(dstFormula, 'Value', ret);
            return true;
        };

        var addition = function(a, b) {
            return parseFloat(a) + parseFloat(b);
        };

        var multiplication = function(a, b) {

            return parseFloat(a) * parseFloat(b);
        };

        var simpleFormula = function(operator) {
            return function(srcPathList, dstFormulaPath) {
                var dstFormula = self.idLUT[dstFormulaPath];
                var dstUnitUrl = self.core.getAttribute(dstFormula, 'Unit');
                var ret = self.core.getAttribute(self.idLUT[srcPathList[0]], 'Value');
                for (var i = 1; i < srcPathList.length; ++i) {
                    var srcNodePath = srcPathList[i];
                    var srcNode = self.idLUT[srcNodePath];
                    var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
                    var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
                    var val = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
                    ret = operator(ret, val);
                };
                self.core.setAttribute(dstFormula, 'Value', ret);
                return true;
            };
        };


        var findSrcNode = function(srcArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("Property" !== baseClass)
                    return;

                var value = self.core.getAttribute(node, 'Value');
                if ("" !== value)
                    srcArray.push(self.core.getPath(node));
            };
        };

        var addVertex = function(dataflow, srcArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                var gmePath = self.core.getPath(node);
                if ("Property" === baseClass) {
                    var value = self.core.getAttribute(node, 'Value');
                    if ("" !== value)
                        srcArray.push(gmePath);
                    dataflow.addNode(gmePath, 1, convertWithEdge);
                } else if ("SimpleFormula" === baseClass) {
                    var type = self.core.getAttribute(node, 'Method');
                    if ("Addition" == type)
                        dataflow.addDyNode(gmePath, simpleFormula(addition));
                    else if ("Multiplication" == type)
                        dataflow.addDyNode(gmePath, simpleFormula(multiplication));
                    else if ("Maximum" == type)
                        dataflow.addDyNode(gmePath, max);
                    else if ("Minimum" == type)
                        dataflow.addDyNode(gmePath, min);
                }
                //var nodePath = self.core.getPath(node);
            };
        };

        var addEdge = function(dataflow) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("ValueFlowComposition" !== baseClass)
                    return;
                var srcPath = self.core.getPointerPath(node, "src");
                var dstPath = self.core.getPointerPath(node, "dst");
                dataflow.addEdge(srcPath, dstPath);
            };
        };


        var isCompatible = function(srcPath, dstPath) {
            var srcNode = self.idLUT[srcPath];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = self.core.getAttribute(dstNode, 'Value');
            return Math.abs(dstUnitVal - convert(srcUnitVal, srcUnitUrl, dstUnitUrl)) < 0.001;
        };

        var index2name = function(index) {
            var path = V.nodeSet[index];
            return self.core.getAttribute(self.idLUT[path], 'name');
        };


        var path2name = function(path) {
            return self.core.getAttribute(self.idLUT[path], 'name');
        };

        var visitLUT = function(fun) {
            for (var k in self.idLUT) {
                fun(self.idLUT[k]);
            }
        };

        var visitAllChildren = function(node, callback) {
            self.core.loadChildren(node, function(err, children) {
                var counter,
                    i,
                    itrCallback,
                    error = '';
                // Check for error in loading before doing recursion.
                if (err) {
                    callback('Could not load children for first object, err: ' + err);
                    return;
                }
                if (children.length === 0) {
                    callback(null);
                    return;
                }
                // Define a counter and callback for the recursion.
                counter = {
                    visits: children.length
                };
                //console.log('Node : ' + node.toString() + ' has ' + children.length.toString() + ' children.');
                itrCallback = function(err) {
                    error = err ? error += err : error;
                    counter.visits -= 1;
                    if (counter.visits === 0) {
                        callback(error);
                    }
                };
                // Iterate over children and invoke recursion
                for (i = 0; i < children.length; i += 1) {
                    var node = children[i];
                    var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                    var gmePath = self.core.getPath(node);
                    console.log("Node name: " + gmePath);
                    self.idLUT[gmePath] = node;
                    visitAllChildrenRec(children[i], counter, itrCallback);
                }
            });
        };

        var visitAllChildrenRec = function(node, counter, callback) {
            self.core.loadChildren(node, function(err, children) {
                var i;
                if (err) {
                    callback('loadChildren failed for ' + node.toString());
                    return;
                }
                //console.log('Node : ' + node.toString() + ' has ' + children.length.toString() + ' children.');
                // The current node's children adds to the counter.
                counter.visits += children.length;
                if (children.length === 0) {
                    // The only chance for callback to be called.
                    callback(null);
                } else {
                    // The current node needs to be accounted for.
                    counter.visits -= 1;
                }
                for (i = 0; i < children.length; i += 1) {
                    var node = children[i];
                    var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                    var gmePath = self.core.getPath(node);
                    console.log("Node name: " + gmePath);
                    self.idLUT[gmePath] = node;
                    visitAllChildrenRec(children[i], counter, callback);
                }
            });
        };
        //start main

        //put the info to gragh
        var srcArray = [];
        var D = new DF.DataFlow();
        //self.sign = false;
        visitAllChildren(activeNode, function(err) {
            if (err) {
                callback(err);
                return;
            }
            console.log('Collected all children :: ');
            //console.log('Total number of nodes  :: ' + selfDotChildren.length);
        });
        visitLUT(addVertex(D, srcArray));
        visitLUT(addEdge(D));
        //self.core.loadChildren(activeNode, traverse(addVertex(D, srcArray)));
        //self.core.loadChildren(activeNode, traverse(addEdge(D)));

        //data flow
        D.setInitList(srcArray);
        //var tmp = D.findCycles();
        D.start();
        // key: sourceNode, value: reachablitySet
        //var reachabilityDic = {};

        //get the reachability closure for each src.
        // for (var i = 0; i < srcArray.length; i += 1) {
        //     var src = srcArray[i];
        //     var reachability = G.localReachability_index(src);
        //     //var reachability = G.localBFS(src, convertWithEdge);
        //     reachabilityDic[src] = new mySet.Set(reachability);

        // };

        //Check the compatibility between each pair of sourceNode.
        // key: node, value: conflictSet
        // var conflictDic = {};
        // for (var i = 0; i < srcArray.length; i += 1) {
        //     for (var j = i + 1; j < srcArray.length; j += 1) {
        //         if (true === isCompatible(srcArray[i], srcArray[j]))
        //             continue;
        //         //when both sourceNode is incompatible
        //         var s1 = reachabilityDic[srcArray[i]];
        //         var s2 = reachabilityDic[srcArray[j]];
        //         var intersection = s1.intersection(s2);
        //         if (0 === intersection.size())
        //             continue;
        //         //when intersection of incompatible reachability set is not empty
        //         var conflict = intersection.getElements();
        //         for (var t = 0; t < conflict.length; t += 1) {
        //             if (null == conflictDic[conflict[t]])
        //                 conflictDic[conflict[t]] = new mySet.Set();
        //             conflictDic[conflict[t]].add(srcArray[i]);
        //             conflictDic[conflict[t]].add(srcArray[j]);
        //         }
        //     }
        // }

        //print conflict
        // var printConflict = function() {
        //     for (var i in conflictDic) {
        //         var conflict = conflictDic[i].getElements();
        //         var c = '[';
        //         for (var j = 0; j < conflict.length; j += 1) {
        //             c += path2name(conflict[j]) + ', ';
        //         }
        //         c += ']';
        //         self.logger.error('found ambigious node: ' + index2name(i) + ', conflict exists amoung ' + c);
        //     }
        // };


        //do convertion with those edges found by localBFS, add src, reachablitySet pair to dic.
        // var graphConvertion = function() {
        //     for (var i = 0; i < srcArray.length; i += 1) {
        //         var src = srcArray[i];
        //         //inc building check-------------------------------
        //         var node = self.idLUT[src];
        //         var changed = self.core.getAttribute(node, 'Changed');
        //         if ("false" === changed)
        //             continue;
        //         //---------------------------------------
        //         var reachability = G.localBFS(src, convertWithEdge);
        //     }
        // };



        // if (0 === size_dict(conflictDic)) {
        // graphConvertion();
        var end = (new Date()).getTime();
        console.log("time:" + (end - start) + "ms");
        self.result.setSuccess(true);
        self.save('added obj', function(err) {
            callback(null, self.result);
        });

        // } else {
        //     printConflict();
        //     var end = (new Date()).getTime();
        //     console.log("time:" + (end - start) + "ms");
        //     self.result.setSuccess(false);
        //     callback(null, self.result);
        // };

    };

    return FormulaEvaluator;
});