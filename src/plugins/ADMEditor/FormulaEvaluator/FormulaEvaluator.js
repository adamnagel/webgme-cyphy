/**
 * Generated by PluginGenerator from webgme on Wed Aug 06 2014 14:03:02 GMT-0500 (Central Daylight Time).
 */

define(['plugin/PluginConfig', 'plugin/PluginBase', 'plugin/FormulaEvaluator/FormulaEvaluator/meta', 'plugin/FormulaEvaluator/FormulaEvaluator/dgraph','plugin/FormulaEvaluator/FormulaEvaluator/set'], function(PluginConfig, PluginBase, MetaTypes, Dgraph, mySet) {
    'use strict';

    /**
     * Initializes a new instance of FormulaEvaluator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin FormulaEvaluator.
     * @constructor
     */
    var FormulaEvaluator = function() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.idLUT = {};
    };

    // Prototypal inheritance from PluginBase.
    FormulaEvaluator.prototype = Object.create(PluginBase.prototype);
    FormulaEvaluator.prototype.constructor = FormulaEvaluator;

    /**
     * Gets the name of the FormulaEvaluator.
     * @returns {string} The name of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getName = function() {
        return "FormulaEvaluator";
    };

    /**
     * Gets the semantic version (semver.org) of the FormulaEvaluator.
     * @returns {string} The version of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getVersion = function() {
        return "0.1.0";
    };

    function _importJS(file) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file, false);
        xhr.send();
        var a = document.createElement("script");
        a.type = "text/javascript";
        a.text = xhr.responseText;
        document.getElementsByTagName("head")[0].appendChild(a);
    };

    function findServer(url) {
        var transport = new Thrift.Transport(url);
        var protocol = new Thrift.Protocol(transport);
        var client = new qudt4dt.thrift.Qudt4dt_baseClient(protocol);
        return client;
    };

    function convert(srcVal, srcUrl, dstUrl) {
        var client = findServer("http://localhost:8080/servlet/unit");
        var srcUnit = client.query(srcUrl);
        var srcQuantity = new qudt4dt.thrift.Quantity();
        srcQuantity.unit = srcUnit;
        srcQuantity.value = srcVal;
        var srcInfo = client.list_domain_unitset(srcQuantity);
        var dstQuantity = client.quantity_convert(srcQuantity, dstUrl);
        var dstInfo = client.list_domain_unitset(dstQuantity);
        return dstQuantity.value;
    };

    function size_dict(d) {
        var c = 0;
        for (var i in d)
        ++c;
        return c;
    };

    function traverse(doWith) {
        return function(err, children) {
            for (var i = 0; i < children.length; i += 1) {
                doWith(children[i]);
            }
        };
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */

    FormulaEvaluator.prototype.main = function(callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        self.updateMETA(self.metaTypes);

        var activeNode = self.activeNode;
        var start = (new Date()).getTime();

        //some utils
        _importJS("http://localhost:8080/servlet/thrift.js");
        _importJS("http://localhost:8080/servlet/gen-js/protocal_types.js");
        _importJS("http://localhost:8080/servlet/gen-js/Qudt4dt_base.js");

        var addComponentWithPath = function(node) {
            var gmePath = self.core.getPath(node);
            self.idLUT[gmePath] = node;
            //self.logger.info(gmePath+ ',' +self.idLUT[gmePath]);
        };

        var findSrcNode = function(srcArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("Property" !== baseClass)
                    return;

                var value = self.core.getAttribute(node, 'Value');
                if ("" !== value)
                    srcArray.push(self.core.getPath(node));
            };
        };

        var addVertex = function(vertexArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("Property" !== baseClass)
                    return;
                var nodePath = self.core.getPath(node);
                vertexArray.add(nodePath);
            };
        };

        var addEdge = function(graph) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("ValueFlowComposition" !== baseClass)
                    return;
                var srcPath = self.core.getPointerPath(node, "src");
                var dstPath = self.core.getPointerPath(node, "dst");
                graph.addEdge(srcPath, dstPath);
            };
        };

        var convertWithEdge = function(srcPath, dstPath) {
            var start = (new Date()).getTime();
            var srcNode = self.idLUT[srcPath];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
            self.core.setAttribute(dstNode, 'Value', dstUnitVal);
            var end = (new Date()).getTime();
            console.log("Node Time:" + (end - start) + "ms");
        };

        var isCompatible = function(srcPath, dstPath) {
            var srcNode = self.idLUT[srcPath];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = self.core.getAttribute(dstNode, 'Value');
            return Math.abs(dstUnitVal - convert(srcUnitVal, srcUnitUrl, dstUnitUrl)) < 0.001;
        };

        var index2name = function(index) {
            var path = V.nodeSet[index];
            return self.core.getAttribute(self.idLUT[path], 'name');
        };


        var path2name = function(path) {
            return self.core.getAttribute(self.idLUT[path], 'name');
        };

        //start main
        //add path
        self.core.loadChildren(activeNode, traverse(addComponentWithPath));

        //find source node
        var srcArray = [];
        self.core.loadChildren(activeNode, traverse(findSrcNode(srcArray)));


        //put info to gragh
        var G = new Dgraph.DGraph();
        var V = new Dgraph.VertexArray();

        self.core.loadChildren(activeNode, traverse(addVertex(V)));
        G.addVertexSet(V);
        self.core.loadChildren(activeNode, traverse(addEdge(G)));


        // key: sourceNode, value: reachablitySet
        var reachabilityDic = {};

        //get the reachability closure for each src.
        for (var i = 0; i < srcArray.length; i += 1) {
            var src = srcArray[i];
            var reachability = G.localReachability_index(src);
            //var reachability = G.localBFS(src, convertWithEdge);
            reachabilityDic[src] = new mySet.Set(reachability);

        };

        //Check the compatibility between each pair of sourceNode.
        // key: node, value: conflictSet
        var conflictDic = {};
        for (var i = 0; i < srcArray.length; i += 1) {
            for (var j = i + 1; j < srcArray.length; j += 1) {
                if (true === isCompatible(srcArray[i], srcArray[j]))
                    continue;
                //when both sourceNode is incompatible
                var s1 = reachabilityDic[srcArray[i]];
                var s2 = reachabilityDic[srcArray[j]];
                var intersection = s1.intersection(s2);
                if (0 === intersection.size())
                    continue;
                //when intersection of incompatible reachability set is not empty
                var conflict = intersection.getElements();
                for (var t = 0; t < conflict.length; t += 1) {
                    if (null == conflictDic[conflict[t]])
                        conflictDic[conflict[t]] = new mySet.Set();
                    conflictDic[conflict[t]].add(srcArray[i]);
                    conflictDic[conflict[t]].add(srcArray[j]);
                }
            }
        }

        //print conflict
        var printConflict = function() {
            for (var i in conflictDic) {
                var conflict = conflictDic[i].getElements();
                var c = '[';
                for (var j = 0; j < conflict.length; j += 1) {
                    c += path2name(conflict[j]) + ', ';
                }
                c += ']';
                self.logger.error('found ambigious node: ' + index2name(i) + ', conflict exists amoung ' + c);
            }
        };


        //do convertion with those edges found by localBFS, add src, reachablitySet pair to dic.
        var graphConvertion = function() {
            for (var i = 0; i < srcArray.length; i += 1) {
                var src = srcArray[i];
                //inc building check-------------------------------
                var node = self.idLUT[src];
                var changed = self.core.getAttribute(node, 'Changed');
                if ("false" === changed)
                    continue;
                //---------------------------------------
                var reachability = G.localBFS(src, convertWithEdge);
            }
        };



        if (0 === size_dict(conflictDic)) {
            graphConvertion();
            var end = (new Date()).getTime();
            console.log("time:" + (end - start) + "ms");
            self.result.setSuccess(true);
            self.save('added obj', function(err) {
            callback(null, self.result);
            });

        } else {
            printConflict();
            var end = (new Date()).getTime();
            console.log("time:" + (end - start) + "ms");
            self.result.setSuccess(false);
            callback(null, self.result);
        };

    };

    return FormulaEvaluator;
});