/**
 * Generated by PluginGenerator from webgme on Wed Aug 06 2014 14:03:02 GMT-0500 (Central Daylight Time).
 */

define(['plugin/PluginConfig', 'plugin/PluginBase', 'plugin/FormulaEvaluator/FormulaEvaluator/meta', 'plugin/FormulaEvaluator/FormulaEvaluator/dgraph', 'plugin/FormulaEvaluator/FormulaEvaluator/set', 'plugin/FormulaEvaluator/FormulaEvaluator/dataflow'], function(PluginConfig, PluginBase, MetaTypes, Dgraph, mySet, DF) {
    'use strict';

    /**
     * Initializes a new instance of FormulaEvaluator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin FormulaEvaluator.
     * @constructor
     */
    var FormulaEvaluator = function() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.idLUT = {};
    };

    // Prototypal inheritance from PluginBase.
    FormulaEvaluator.prototype = Object.create(PluginBase.prototype);
    FormulaEvaluator.prototype.constructor = FormulaEvaluator;

    /**
     * Gets the name of the FormulaEvaluator.
     * @returns {string} The name of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getName = function() {
        return "FormulaEvaluator";
    };

    /**
     * Gets the semantic version (semver.org) of the FormulaEvaluator.
     * @returns {string} The version of the plugin.
     * @public
     */
    FormulaEvaluator.prototype.getVersion = function() {
        return "0.1.0";
    };

    function _importJS(file) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", file, false);
        xhr.send();
        var a = document.createElement("script");
        a.type = "text/javascript";
        a.text = xhr.responseText;
        document.getElementsByTagName("head")[0].appendChild(a);
    };

    function findServer(url) {
        var transport = new Thrift.Transport(url);
        var protocol = new Thrift.Protocol(transport);
        var client = new qudt4dt.thrift.Qudt4dt_baseClient(protocol);
        return client;
    };

    function convert(srcVal, srcUrl, dstUrl) {
        var client = findServer("http://localhost:8080/servlet/unit");
        var srcUnit = client.query(srcUrl);
        var srcQuantity = new qudt4dt.thrift.Quantity();
        srcQuantity.unit = srcUnit;
        srcQuantity.value = srcVal;
        var srcInfo = client.list_domain_unitset(srcQuantity);
        var dstQuantity = client.quantity_convert(srcQuantity, dstUrl);
        var dstInfo = client.list_domain_unitset(dstQuantity);
        return dstQuantity.value;
    };

    function size_dict(d) {
        var c = 0;
        for (var i in d)
        ++c;
        return c;
    };

    function traverse(doWith) {
        return function(err, children) {
            for (var i = 0; i < children.length; i += 1) {
                doWith(children[i]);
            }
        };
    };

    function assert(condition) {
        if (!condition) {
            throw "Assertion failed";
        }
    };
    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */

    FormulaEvaluator.prototype.main = function(callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        self.updateMETA(self.metaTypes);

        var activeNode = self.activeNode;
        var start = (new Date()).getTime();

        //some utils
        _importJS("http://localhost:8080/servlet/thrift.js");
        _importJS("http://localhost:8080/servlet/gen-js/protocal_types.js");
        _importJS("http://localhost:8080/servlet/gen-js/Qudt4dt_base.js");

        var addComponentWithPath = function(node) {
            var gmePath = self.core.getPath(node);
            self.idLUT[gmePath] = node;
            //self.logger.info(gmePath+ ',' +self.idLUT[gmePath]);
        };

        var convertWithEdge = function(srcPathList, dstPath) {
            var start = (new Date()).getTime();
            assert(1 === srcPathList.length);
            var srcNode = self.idLUT[srcPathList[0]];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
            self.core.setAttribute(dstNode, 'Value', dstUnitVal);
            var end = (new Date()).getTime();
            console.log("Node Time:" + (end - start) + "ms");
            return true;
        };

        var simpleFormula = function(srcPathList, dstFormulaPath) {
            var dstFormula = self.idLUT[dstFormulaPath]; 
            var dstUnitUrl = self.core.getAttribute(dstFormula, 'Unit');
            var ret = 0.0;
            for (var i = srcPathList.length - 1; i >= 0; i--) {
                var srcNodePath = srcPathList[i];
                var srcNode     = self.idLUT[srcNodePath];
                var srcUnitUrl  = self.core.getAttribute(srcNode, 'Unit');
                var srcUnitVal  = self.core.getAttribute(srcNode, 'Value');
                var val         = convert(srcUnitVal, srcUnitUrl, dstUnitUrl);
                ret            += val;
            };
            self.core.setAttribute(dstFormula, 'Value', ret);
            return true;
        };


        var findSrcNode = function(srcArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("Property" !== baseClass)
                    return;

                var value = self.core.getAttribute(node, 'Value');
                if ("" !== value)
                    srcArray.push(self.core.getPath(node));
            };
        };

        var addVertex = function(dataflow, srcArray) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                var gmePath = self.core.getPath(node);
                if ("Property" === baseClass) {
                    var value = self.core.getAttribute(node, 'Value');
                    if ("" !== value)
                        srcArray.push(gmePath);
                    dataflow.addNode(gmePath, 1, convertWithEdge);
                } else if ("SimpleFormula" === baseClass) {
                    dataflow.addNode(gmePath, 2, simpleFormula);
                }
                //var nodePath = self.core.getPath(node);
            };
        };

        var addEdge = function(dataflow) {
            return function(node) {
                var baseClass = self.core.getAttribute(self.getMetaType(node), 'name');
                if ("ValueFlowComposition" !== baseClass)
                    return;
                var srcPath = self.core.getPointerPath(node, "src");
                var dstPath = self.core.getPointerPath(node, "dst");
                dataflow.addEdge(srcPath, dstPath);
            };
        };


        var isCompatible = function(srcPath, dstPath) {
            var srcNode = self.idLUT[srcPath];
            var dstNode = self.idLUT[dstPath];
            var srcUnitUrl = self.core.getAttribute(srcNode, 'Unit');
            var dstUnitUrl = self.core.getAttribute(dstNode, 'Unit');
            var srcUnitVal = self.core.getAttribute(srcNode, 'Value');
            var dstUnitVal = self.core.getAttribute(dstNode, 'Value');
            return Math.abs(dstUnitVal - convert(srcUnitVal, srcUnitUrl, dstUnitUrl)) < 0.001;
        };

        var index2name = function(index) {
            var path = V.nodeSet[index];
            return self.core.getAttribute(self.idLUT[path], 'name');
        };


        var path2name = function(path) {
            return self.core.getAttribute(self.idLUT[path], 'name');
        };

        //start main

        //put the info to gragh
        var srcArray = [];
        var D = new DF.DataFlow();

        self.core.loadChildren(activeNode, traverse(addComponentWithPath));
        self.core.loadChildren(activeNode, traverse(addVertex(D, srcArray)));
        self.core.loadChildren(activeNode, traverse(addEdge(D)));

        //data flow
        D.setInitList(srcArray);
        D.start();
        // key: sourceNode, value: reachablitySet
        //var reachabilityDic = {};

        //get the reachability closure for each src.
        // for (var i = 0; i < srcArray.length; i += 1) {
        //     var src = srcArray[i];
        //     var reachability = G.localReachability_index(src);
        //     //var reachability = G.localBFS(src, convertWithEdge);
        //     reachabilityDic[src] = new mySet.Set(reachability);

        // };

        //Check the compatibility between each pair of sourceNode.
        // key: node, value: conflictSet
        // var conflictDic = {};
        // for (var i = 0; i < srcArray.length; i += 1) {
        //     for (var j = i + 1; j < srcArray.length; j += 1) {
        //         if (true === isCompatible(srcArray[i], srcArray[j]))
        //             continue;
        //         //when both sourceNode is incompatible
        //         var s1 = reachabilityDic[srcArray[i]];
        //         var s2 = reachabilityDic[srcArray[j]];
        //         var intersection = s1.intersection(s2);
        //         if (0 === intersection.size())
        //             continue;
        //         //when intersection of incompatible reachability set is not empty
        //         var conflict = intersection.getElements();
        //         for (var t = 0; t < conflict.length; t += 1) {
        //             if (null == conflictDic[conflict[t]])
        //                 conflictDic[conflict[t]] = new mySet.Set();
        //             conflictDic[conflict[t]].add(srcArray[i]);
        //             conflictDic[conflict[t]].add(srcArray[j]);
        //         }
        //     }
        // }

        //print conflict
        // var printConflict = function() {
        //     for (var i in conflictDic) {
        //         var conflict = conflictDic[i].getElements();
        //         var c = '[';
        //         for (var j = 0; j < conflict.length; j += 1) {
        //             c += path2name(conflict[j]) + ', ';
        //         }
        //         c += ']';
        //         self.logger.error('found ambigious node: ' + index2name(i) + ', conflict exists amoung ' + c);
        //     }
        // };


        //do convertion with those edges found by localBFS, add src, reachablitySet pair to dic.
        // var graphConvertion = function() {
        //     for (var i = 0; i < srcArray.length; i += 1) {
        //         var src = srcArray[i];
        //         //inc building check-------------------------------
        //         var node = self.idLUT[src];
        //         var changed = self.core.getAttribute(node, 'Changed');
        //         if ("false" === changed)
        //             continue;
        //         //---------------------------------------
        //         var reachability = G.localBFS(src, convertWithEdge);
        //     }
        // };



        // if (0 === size_dict(conflictDic)) {
        // graphConvertion();
        var end = (new Date()).getTime();
        console.log("time:" + (end - start) + "ms");
        self.result.setSuccess(true);
        self.save('added obj', function(err) {
            callback(null, self.result);
        });

        // } else {
        //     printConflict();
        //     var end = (new Date()).getTime();
        //     console.log("time:" + (end - start) + "ms");
        //     self.result.setSuccess(false);
        //     callback(null, self.result);
        // };

    };

    return FormulaEvaluator;
});